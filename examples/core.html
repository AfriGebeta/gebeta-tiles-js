<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Gebeta Maps - Core Features</title>
  <!-- IMPORTANT: This css file is required for the map to be displayed correctly. -->
  <link rel="stylesheet" href="https://tiles.gebeta.app/static/gebeta-maps-lib.css" />
  <style>
    html, body { height: 100%; margin: 0; }
    .control-panel {
      position: absolute;
      top: 10px;
      left: 10px;
      background: white;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      z-index: 1000;
      max-width: 320px;
      max-height: calc(100vh - 20px);
      overflow: auto;
      resize: both;
      color: #000;
      box-sizing: border-box;
    }
    .control-panel h3 {
      margin: 0 0 10px 0;
      font-size: 16px;
      color: #000;
    }
    .control-panel button {
      display: block;
      width: 100%;
      margin: 5px 0;
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background: #f8f9fa;
      cursor: pointer;
      font-size: 14px;
      color: #000;
      box-sizing: border-box;
    }
    .control-panel button:hover {
      background: #e9ecef;
    }
    .control-panel .points {
      margin-top: 10px;
      color: #000;
    }
    .control-panel .points ul {
        list-style: none;
        padding: 0;
        margin: 0;
        color: #000;
    }
    .control-panel .name-input {
      margin-top: 10px;
      display: flex;
      gap: 6px;
      align-items: center;
    }
    .control-panel .name-input input {
      flex: 1;
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 6px 8px;
      font-size: 14px;
      color: #000;
      box-sizing: border-box;
    }
    .control-panel .inline {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 6px;
      font-size: 12px;
      color: #000;
    }
    .control-panel textarea {
        width: 100%;
        margin: 5px 0;
        padding: 8px 12px;
        border: 1px solid #ddd;
        border-radius: 4px;
        background: #f8f9fa;
        cursor: text;
        font-size: 11px;
        font-family: 'Courier New', monospace;
        color: #000;
        resize: vertical;
        box-sizing: border-box;
        overflow-wrap: anywhere;
        word-break: break-word;
    }
    .control-panel textarea:focus {
        background: white;
        border-color: #007bff;
        outline: none;
    }
    /* Switch styles */
    .switch { display: flex; align-items: center; gap: 10px; margin-top: 6px; }
    .switch .switch-label { font-size: 12px; color: #000; }
    .switch input { height: 0; width: 0; visibility: hidden; }
    .switch .slider {
      cursor: pointer; width: 42px; height: 22px; background: #cfcfcf; display: inline-block; border-radius: 999px; position: relative;
    }
    .switch .slider::after {
      content: ''; position: absolute; top: 2px; left: 2px; width: 18px; height: 18px; background: #fff; border-radius: 50%; transition: transform 0.2s ease;
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }
    .switch input:checked + .slider { background: #007bff; }
    .switch input:checked + .slider::after { transform: translateX(20px); }
    /* Simple on-map label style */
    .fence-label {
      padding: 4px 8px;
      background: white;
      border: 2px solid #333;
      border-radius: 6px;
      font-size: 12px;
      color: #111;
      white-space: nowrap;
      box-shadow: 0 1px 4px rgba(0,0,0,0.2);
      transform: translateY(-6px);
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="map" style="width: 100vw; height: 100vh;"></div>
  
  <div class="control-panel">
    <h3>Core Features - Fence Drawing</h3>
    <button onclick="addFencePoint()">Add Fence Point (Click Map)</button>
    <button onclick="setGreenDefaultColor()">Set Green Default Color</button>
    <button onclick="resetToRandomColors()">Reset to Random Colors</button>
    <button onclick="clearFence()">Clear Current Fence (C)</button>
    <button onclick="clearAllFences()">Clear All Fences</button>
    <div class="points">
        <strong>Fence Points:</strong><br>
        <details open>
          <summary style="cursor:pointer;">Show/Hide Points</summary>
          <ul id="fence-points-list">
              <!-- Fence points will be dynamically added here -->
          </ul>
        </details>
    </div>
    <div class="name-input">
      <label for="fence-name-input" style="font-size:12px; color:#555;">Name:</label>
      <input id="fence-name-input" type="text" placeholder="Fence name (optional)" />
    </div>
    <label class="switch" for="fence-persistent">
      <input type="checkbox" id="fence-persistent" />
      <span class="slider"></span>
      <span class="switch-label">Persistent (keep when new fence starts)</span>
    </label>
    <div style="margin: 10px 0;">
        <label for="pathsInput" style="display: block; margin-bottom: 5px; font-size: 12px;">Enter paths (JSON):</label>
        <textarea id="pathsInput" rows="4" placeholder='Examples:\n1) Array of paths: [ [ [lng,lat], ... ], [ [lng,lat], ... ] ]\n2) Named paths: [ {"name":"Zone A", "points": [ [lng,lat], ... ]}, {"name":"Zone B", "points": [...] } ]'></textarea>
        <button onclick="renderMultiplePaths()" style="margin-top: 5px;">Render Paths as Fences</button>
        <button onclick="loadSamplePaths()" style="margin-top: 5px; margin-left: 5px;">Load Sample (with names)</button>
        <label class="switch" for="paths-persistent">
          <input type="checkbox" id="paths-persistent" />
          <span class="slider"></span>
          <span class="switch-label">Persistent when rendering paths</span>
        </label>
    </div>
  </div>

  <!-- IMPORTANT: load the gebeta-maps.umd.js file from the tiles.gebeta.app cdn server. -->
  <!-- <script type="module" src="https://tiles.gebeta.app/static/gebeta-maps.umd.js"></script> -->
   <script src="../dist/gebeta-maps.umd.js"></script>
  <!-- this is just a utility to load the env for all examples -->
  <script src="config.js"></script>

<script>
    let gebetaMap;
    let map;
    let fencePoints = [];
    let useRandomColors = true; // Default to random colors
    let currentFenceColor = null; // Track current fence color
    // Labels are now handled by FenceManager overlays

    document.addEventListener('DOMContentLoaded', () => {
        const config = loadConfig();
        const MY_GEBETA_API_KEY = config.GEBETA_API_KEY;
        
        gebetaMap = new GebetaMaps({ 
            apiKey: MY_GEBETA_API_KEY
        });
        
        // Register the fence completed event
        gebetaMap.on('fenceCompleted', (data) => {
            console.log('Fence completed!');
            fencePoints = [];
            const fencePointsList = document.getElementById('fence-points-list');
            if (fencePointsList) fencePointsList.innerHTML = '';
            if (useRandomColors) currentFenceColor = generateRandomColor();
        });

        map = gebetaMap.init({
            container: 'map',
            center: [38.7685, 9.0161],
            zoom: 15,
        });

        map.on('load', () => {
            gebetaMap.addNavigationControls();
        });

        gebetaMap.on('click', (e) => {
            const lngLat = [e.lngLat.lng, e.lngLat.lat];
            
            // Generate color for first fence if random colors are enabled and no color is set yet
            if (useRandomColors && currentFenceColor === null && fencePoints.length === 0) {
                currentFenceColor = generateRandomColor();
                console.log('Generated first random color for fence:', currentFenceColor);
            }
            
            // If a fence is completed, always start a new one in the UI list as well
            if (gebetaMap.isFenceCompleted()) {
                console.log('Fence completed (detected in click handler)', gebetaMap.isFenceCompleted());
                fencePoints = [];
                const fencePointsList = document.getElementById('fence-points-list');
                if (fencePointsList) fencePointsList.innerHTML = '';
                if (useRandomColors) currentFenceColor = generateRandomColor();
            }
            
            // Add the fence point (this will be the first point of the new fence if we just cleared)
            const nameInput = document.getElementById('fence-name-input');
            const fenceName = nameInput && nameInput.value ? nameInput.value : '';
            const persistent = !!document.getElementById('fence-persistent').checked;
            const overlayHtml = fenceName
                ? `<div style="padding:4px 8px;background:#fff;border:2px solid ${currentFenceColor || '#333'};border-radius:6px;font-size:12px;color:#111;white-space:nowrap;box-shadow:0 1px 4px rgba(0,0,0,0.2);transform:translateY(-6px);">${fenceName}</div>`
                : null;
            const isFirstPoint = fencePoints.length === 0;
            const options = isFirstPoint
                ? (overlayHtml ? { overlayHtml, overlayOptions: { anchor: 'bottom' }, persistent } : { persistent })
                : { persistent };
                
            gebetaMap.addFencePoint(lngLat, null, null, currentFenceColor, options);
            fencePoints.push(lngLat);

            console.log('Added fence point:', lngLat);
            // Update the fence points list in the control panel
            const fencePointsList = document.getElementById('fence-points-list');
            if (fencePointsList) {
                const listItem = document.createElement('li');
                listItem.textContent = `Point ${fencePoints.length}: [${lngLat[1].toFixed(4)}, ${lngLat[0].toFixed(4)}]`;
                fencePointsList.appendChild(listItem);
            }
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'c') {
                gebetaMap.clearFence();
            }
        });

        map.on('error', (e) => {
            const mapContainer = document.getElementById('map');
            if (mapContainer) {
                mapContainer.innerHTML = `<div style="padding: 20px; text-align: center;">
                    <h2>Could not load map style</h2>
                    <p>Please ensure the style server at <code>https://tiles.gebeta.app</code> is reachable.</p>
                </div>`;
            }
        });
    });

    function addFencePoint() {
        if (!gebetaMap) return;
        console.log('Click on the map to add fence points');
    }

    // Removed extra demo marker buttons to simplify the UI

    function setGreenDefaultColor() {
        if (!gebetaMap) return;
        
        // Set the default color for new fences to green
        gebetaMap.setFenceDefaultColor('#00cc00');
        useRandomColors = false; // Disable random colors
        currentFenceColor = '#00cc00';
        console.log('Set default fence color to green');
        alert('Default fence color set to green. New fences will be green.');
    }

    function generateRandomColor() {
        // Generate a random color with good contrast
        const colors = [
            '#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff',
            '#ff6600', '#6600ff', '#00ff66', '#ff0066', '#0066ff', '#66ff00',
            '#ff9900', '#9900ff', '#00ff99', '#ff0099', '#0099ff', '#99ff00',
            '#cc6600', '#6600cc', '#00cc66', '#cc0066', '#0066cc', '#66cc00'
        ];
        return colors[Math.floor(Math.random() * colors.length)];
    }

    function resetToRandomColors() {
        if (!gebetaMap) return;
        
        useRandomColors = true;
        currentFenceColor = null;
        gebetaMap.setFenceDefaultColor('#ff0000'); // Reset to default red
        console.log('Reset to random colors mode');
        alert('Reset to random colors mode. Each new fence will have a random color.');
    }

    function clearFence() {
        if (!gebetaMap) return;
        gebetaMap.clearFence();
        console.log('Fence cleared');

        // Overlays are cleared by fence utilities
        
        // Reset the info panel
        const infoPanel = document.querySelector('.info');
        if (infoPanel) {
            infoPanel.innerHTML = `
                <strong>Instructions:</strong><br>
                • Click on the map to add fence points<br>
                • Each new fence gets a random color by default<br>
                • A colored dashed line follows your cursor while drawing<br>
                • Click on any existing fence point to close the fence<br>
                • Add at least 3 points to draw a complete fence<br>
                • Click outside a completed fence to start a new one<br>
                • Press 'C' to clear the fence<br>
                • Custom fence points can have custom images and colors
            `;
        }
    }

    function clearAllFences() {
        if (!gebetaMap) return;
        gebetaMap.clearAllFences();
        console.log('All fences cleared');

        // Overlays are cleared by fence utilities
        
        // Reset the info panel
        const infoPanel = document.querySelector('.info');
        if (infoPanel) {
            infoPanel.innerHTML = `
                <strong>Instructions:</strong><br>
                • Click on the map to add fence points<br>
                • Each new fence gets a random color by default<br>
                • A colored dashed line follows your cursor while drawing<br>
                • Click on any existing fence point to close the fence<br>
                • Add at least 3 points to draw a complete fence<br>
                • Click outside a completed fence to start a new one<br>
                • Multiple fences can coexist on the map<br>
                • Press 'C' to clear the current fence<br>
                • Custom fence points can have custom images and colors
            `;
        }
    }

    // Multi-path rendering with optional names and overlays
    function renderMultiplePaths() {
        if (!gebetaMap) return;
        const inputEl = document.getElementById('pathsInput');
        const text = inputEl.value.trim();
        if (!text) {
            alert('Please enter paths in the text area.');
            return;
        }
        let paths;
        try {
            paths = JSON.parse(text);
        } catch (e) {
            alert('Invalid JSON.');
            return;
        }
        // Render via built-in helper
        const persistent = !!document.getElementById('paths-persistent').checked;
        gebetaMap.renderFencesFromArray(paths, { clearExisting: true, autoColor: true, hueStep: 180, overlayAnchor: 'bottom', persistent });

        // Populate the points list UI
        const fencePointsList = document.getElementById('fence-points-list');
        if (fencePointsList) {
            fencePointsList.innerHTML = '';
            (Array.isArray(paths) ? paths : []).forEach((item, idx) => {
                const name = (item && item.name) ? item.name : `Path ${idx + 1}`;
                const pts = Array.isArray(item) ? item : (item && Array.isArray(item.points) ? item.points : []);
                const header = document.createElement('li');
                header.innerHTML = `<strong>${name} (${pts.length} points)</strong>`;
                fencePointsList.appendChild(header);
                pts.forEach((p, i) => {
                    const li = document.createElement('li');
                    li.textContent = `  Point ${i + 1}: [${p[1].toFixed(4)}, ${p[0].toFixed(4)}]`;
                    fencePointsList.appendChild(li);
                });
            });
        }
    }

    function loadSamplePaths() {
        const sample = [
            { name: 'Zone A', points: [ [38.844317557306,9.038652398071], [38.844735981912,9.0368458417574], [38.845487000436,9.0357862737222], [38.84822821805,9.0361253358325], [38.847984137029,9.0387464651468] ] },
            { name: 'Zone B', points: [ [38.719653382914,8.9697856689243], [38.715812459605,8.9671574472011], [38.702487245219,8.9739929035992], [38.702487245219,8.9791114633748], [38.70528747143,8.9813792907801], [38.71154771461,8.9811699458284], [38.71432648315,8.9800360332441], [38.71827469482,8.9761573895587], [38.721815210719,8.9735080189377], [38.719669443507,8.9696822936261] ] }
        ];
        const inputEl = document.getElementById('pathsInput');
        inputEl.value = JSON.stringify(sample, null, 2);
        // Use the new helper to render
        const persistent = !!document.getElementById('paths-persistent').checked;
        gebetaMap.renderFencesFromArray(sample, { clearExisting: true, autoColor: true, hueStep: 180, overlayAnchor: 'bottom', persistent });

        // Update UI list
        const fencePointsList = document.getElementById('fence-points-list');
        if (fencePointsList) {
            fencePointsList.innerHTML = '';
            sample.forEach((item, idx) => {
                const name = item.name || `Path ${idx + 1}`;
                const header = document.createElement('li');
                header.innerHTML = `<strong>${name} (${item.points.length} points)</strong>`;
                fencePointsList.appendChild(header);
                item.points.forEach((p, i) => {
                    const li = document.createElement('li');
                    li.textContent = `  Point ${i + 1}: [${p[1].toFixed(4)}, ${p[0].toFixed(4)}]`;
                    fencePointsList.appendChild(li);
                });
            });
        }
    }

    // No local label utilities needed; overlays handled by FenceManager
</script>

</body>
</html> 