<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Gebeta Maps - Navigation with Simulated Location</title>
  <link rel="stylesheet" href="https://tiles.gebeta.app/static/gebeta-maps-lib.css" />
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
    }
    #map {
      width: 100vw;
      height: 100vh;
    }
    .controls {
      position: absolute;
      top: 10px;
      left: 10px;
      right: 10px;
      z-index: 1000;
      max-width: 500px;
      background: white;
      padding: 16px;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }
    .controls h3 {
      margin: 0 0 12px 0;
      font-size: 18px;
      color: #333;
    }
    .controls p {
      margin: 0 0 12px 0;
      font-size: 14px;
      color: #666;
    }
    .input-group {
      margin-bottom: 12px;
    }
    .input-group label {
      display: block;
      margin-bottom: 4px;
      font-size: 14px;
      font-weight: 500;
      color: #333;
    }
    .input-group input {
      width: 100%;
      padding: 8px 12px;
      border: 2px solid #e0e0e0;
      border-radius: 6px;
      font-size: 14px;
      box-sizing: border-box;
    }
    .input-group input:focus {
      outline: none;
      border-color: #007cbf;
    }
    .button-group {
      display: flex;
      gap: 8px;
      margin-top: 16px;
    }
    button {
      flex: 1;
      padding: 10px 16px;
      border: none;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    button.primary {
      background: #007cbf;
      color: white;
    }
    button.primary:hover {
      background: #005a8b;
    }
    button.danger {
      background: #e53955;
      color: white;
    }
    button.danger:hover {
      background: #c82333;
    }
    button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    .status {
      margin-top: 12px;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 13px;
      background: #f0f0f0;
      color: #333;
    }
    .status.active {
      background: #d4edda;
      color: #155724;
    }
    .status.error {
      background: #f8d7da;
      color: #721c24;
    }
    .nav-toggle-btn {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      background: #007cbf;
      color: white;
      border: none;
      border-radius: 24px;
      padding: 12px 32px;
      font-size: 14px;
      font-weight: 700;
      box-shadow: 0 8px 18px rgba(0,0,0,0.35);
      cursor: pointer;
      z-index: 1300;
      width: 180px;
      text-align: center;
      transition: background-color 0.2s ease;
      display: none;
    }
    .nav-toggle-btn.stop {
      background: #e53955;
    }
    .controls.navigation-mode {
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="map" style="width: 100vw; height: 100vh;"></div>
  
  <div class="controls" id="controls">
    <h3>Navigation with Simulated Location</h3>
    <p>This example uses a custom location provider that simulates movement along a route. Perfect for testing tracking without moving your device.</p>
    
    <div class="input-group">
      <label for="userId">User ID (required)</label>
      <input type="text" id="userId" placeholder="e.g., DR_1" value="DR_1" />
    </div>
    
    <div class="input-group">
      <label for="speed">Simulation Speed (km/h)</label>
      <input type="number" id="speed" placeholder="30" value="30" min="1" max="120" />
    </div>
    
    <div class="button-group">
      <button class="primary" id="startBtn" onclick="startSimulation()">Start Navigation</button>
    </div>
    
    <div class="status" id="status">Ready to start</div>
  </div>

  <button class="nav-toggle-btn" id="navToggleButton" onclick="toggleNavigation()">Stop Navigation</button>

  <script src="../dist/gebeta-maps.umd.js"></script>
  <script src="config.js"></script>
  <script>
    let gebetaMap;
    let map;
    let simulatedRoute = null;
    let customLocationProvider = null;
    let simulationInterval = null;
    let currentRouteIndex = 0;
    let navigationUI = null;

    // NavigationUI is now exported from the SDK
    // You can use it directly or extend it to customize the UI
    // Example: class CustomNavigationUI extends NavigationUI { ... }
    const NavigationUI = window.NavigationUI;

    // Custom location provider that simulates movement along a route
    function createSimulatedLocationProvider(route, speedKmh = 30) {
      if (!route || !route.geometry || !route.geometry.coordinates) {
        throw new Error('Route with geometry.coordinates is required');
      }

      const coordinates = route.geometry.coordinates; // [lng, lat] format
      let currentIndex = 0;
      let intervalId = null;
      let onLocationCallbacks = []; // Support multiple callbacks

      // Calculate distance between two points in meters
      function haversineDistance(coord1, coord2) {
        const R = 6371000; // Earth radius in meters
        const lat1 = coord1[1] * Math.PI / 180;
        const lat2 = coord2[1] * Math.PI / 180;
        const dLat = (coord2[1] - coord1[1]) * Math.PI / 180;
        const dLng = (coord2[0] - coord1[0]) * Math.PI / 180;
        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                  Math.cos(lat1) * Math.cos(lat2) *
                  Math.sin(dLng / 2) * Math.sin(dLng / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
      }

      // Calculate bearing between two points
      function calculateBearing(coord1, coord2) {
        const lat1 = coord1[1] * Math.PI / 180;
        const lat2 = coord2[1] * Math.PI / 180;
        const dLng = (coord2[0] - coord1[0]) * Math.PI / 180;
        const y = Math.sin(dLng) * Math.cos(lat2);
        const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLng);
        const bearing = Math.atan2(y, x);
        return (bearing * 180 / Math.PI + 360) % 360;
      }

      // Interpolate between two coordinates
      function interpolate(coord1, coord2, fraction) {
        return [
          coord1[0] + (coord2[0] - coord1[0]) * fraction,
          coord1[1] + (coord2[1] - coord1[1]) * fraction
        ];
      }

      return {
        start: (onLocation) => {
          // Add callback to list (support multiple consumers)
          if (onLocationCallbacks.indexOf(onLocation) === -1) {
            onLocationCallbacks.push(onLocation);
          }
          
          // Start simulation if not already running
          if (intervalId === null) {
            currentIndex = 0;
          
            // Start from first coordinate
            const startCoord = coordinates[0];
            const startLocation = {
              lat: startCoord[1],
              lng: startCoord[0],
              speed: speedKmh * 1000 / 3600, // Convert km/h to m/s
              bearing: coordinates.length > 1 ? calculateBearing(coordinates[0], coordinates[1]) : 0,
              timestamp: Date.now()
            };
            onLocationCallbacks.forEach(cb => cb(startLocation));

          // Calculate update interval based on speed
          // Faster speeds update more frequently for smoother animation
          const speedMs = speedKmh * 1000 / 3600; // m/s
          // Update interval: faster speeds = more frequent updates (but cap at reasonable limits)
          // At 30 km/h: 500ms updates, at 60 km/h: 250ms, at 120 km/h: 125ms
          const baseUpdateInterval = 500; // Base interval in ms
          const updateInterval = Math.max(100, Math.min(1000, baseUpdateInterval * (30 / speedKmh)));
          const distancePerUpdate = speedMs * (updateInterval / 1000); // meters per update
          
          let segmentProgress = 0;
          let currentSegment = 0;

          intervalId = setInterval(() => {
            if (currentSegment >= coordinates.length - 1) {
              // Reached destination
              clearInterval(intervalId);
              return;
            }

            const coord1 = coordinates[currentSegment];
            const coord2 = coordinates[currentSegment + 1];
            const segmentDistance = haversineDistance(coord1, coord2);
            
            segmentProgress += distancePerUpdate / segmentDistance;

            if (segmentProgress >= 1) {
              // Move to next segment
              segmentProgress = 0;
              currentSegment++;
              
              if (currentSegment >= coordinates.length - 1) {
                // Reached destination
                clearInterval(intervalId);
                return;
              }
            }

            // Interpolate position
            const nextCoord1 = coordinates[currentSegment];
            const nextCoord2 = coordinates[currentSegment + 1];
            const [lng, lat] = interpolate(nextCoord1, nextCoord2, segmentProgress);
            const bearing = calculateBearing(nextCoord1, nextCoord2);

            const location = {
              lat,
              lng,
              speed: speedMs,
              bearing,
              timestamp: Date.now()
            };

            // Call all registered callbacks
            onLocationCallbacks.forEach(callback => {
              try {
                callback(location);
              } catch (err) {
                console.error('Error in location callback:', err);
              }
            });
          }, updateInterval);

          }
          
          // Return stop function for this specific callback
          return () => {
            const index = onLocationCallbacks.indexOf(onLocation);
            if (index > -1) {
              onLocationCallbacks.splice(index, 1);
            }
            // Stop interval if no more callbacks
            if (onLocationCallbacks.length === 0 && intervalId) {
              clearInterval(intervalId);
              intervalId = null;
            }
          };
        },
        stop: () => {
          if (intervalId) {
            clearInterval(intervalId);
            intervalId = null;
          }
          onLocationCallbacks = [];
        }
      };
    }

    function generateRandomRoute() {
      // Addis Ababa bounding box
      const minLat = 8.9;
      const maxLat = 9.1;
      const minLng = 38.6;
      const maxLng = 38.9;
      
      // Generate random origin
      const origin = {
        lat: minLat + Math.random() * (maxLat - minLat),
        lng: minLng + Math.random() * (maxLng - minLng)
      };
      
      // Generate random destination (ensuring minimum distance)
      let destination;
      let attempts = 0;
      do {
        destination = {
          lat: minLat + Math.random() * (maxLat - minLat),
          lng: minLng + Math.random() * (maxLng - minLng)
        };
        attempts++;
        // Calculate distance
        const dLat = destination.lat - origin.lat;
        const dLng = destination.lng - origin.lng;
        const distance = Math.sqrt(dLat * dLat + dLng * dLng);
        // Ensure at least 0.02 degrees apart (roughly 2km)
        if (distance >= 0.02 || attempts > 10) break;
      } while (attempts < 10);
      
      return { origin, destination };
    }

    async function startSimulation() {
      const userId = document.getElementById('userId').value.trim() || 'DR_1';
      const speed = parseFloat(document.getElementById('speed').value) || 30;

      if (!userId) {
        updateStatus('Please provide user ID', 'error');
        return;
      }

      try {
        updateStatus('Calculating route...', '');
        
        // Generate random route (Addis Ababa area)
        const { origin, destination } = generateRandomRoute();
        
        // Update map center to show the route area
        const centerLat = (origin.lat + destination.lat) / 2;
        const centerLng = (origin.lng + destination.lng) / 2;
        map.flyTo({
          center: [centerLng, centerLat],
          zoom: 13,
          duration: 1000
        });

        // Get route
        const route = await gebetaMap.getDirections(origin, destination);
        simulatedRoute = route;

        // Display route on map
        gebetaMap.displayRoute(route, { showMarkers: true });

        // Create custom location provider
        customLocationProvider = createSimulatedLocationProvider(route, speed);

        updateStatus('Starting navigation with simulated location...', '');

        // Start navigation with custom provider
        await gebetaMap.startNavigation({
          route,
          userId,
          role: 'driver',
          locationProvider: customLocationProvider
        });

        // Create and mount navigation UI
        const navController = gebetaMap.getNavigationController();
        if (!navigationUI) {
          navigationUI = new NavigationUI(map, navController, {
            onStop: () => {
              stopSimulation();
            }
          });
          navigationUI.mount();
        }
        

        // Update UI
        document.getElementById('controls').classList.add('navigation-mode');
        document.getElementById('navToggleButton').style.display = 'block';
        updateStatus('Navigation active - location is being simulated', 'active');
        document.getElementById('startBtn').disabled = true;

      } catch (error) {
        console.error('Error starting simulation:', error);
        updateStatus('Error: ' + error.message, 'error');
      }
    }

    function stopSimulation() {
      gebetaMap.stopNavigation();
      
      if (customLocationProvider) {
        customLocationProvider.stop();
        customLocationProvider = null;
      }

      if (navigationUI) {
        navigationUI.hide();
        navigationUI = null;
      }

      // Update UI
      document.getElementById('controls').classList.remove('navigation-mode');
      document.getElementById('navToggleButton').style.display = 'none';
      updateStatus('Navigation stopped', '');
      document.getElementById('startBtn').disabled = false;
    }

    function toggleNavigation() {
      const navController = gebetaMap.getNavigationController();
      const isNavigating = navController && navController._active;
      
      if (isNavigating) {
        stopSimulation();
      }
    }

    function updateStatus(message, type) {
      const statusEl = document.getElementById('status');
      statusEl.textContent = message;
      statusEl.className = 'status' + (type ? ' ' + type : '');
    }

    // Initialize map
    window.addEventListener('DOMContentLoaded', async () => {
      const config = loadConfig();
      const MY_GEBETA_API_KEY = config.GEBETA_API_KEY;
      
      gebetaMap = new GebetaMaps({ 
        apiKey: MY_GEBETA_API_KEY
      });

      map = gebetaMap.init({
        container: 'map',
        center: [38.7750, 9.0175],
        zoom: 12,
      });

      map.on('load', () => {
        gebetaMap.addNavigationControls();
        updateStatus('Map loaded - ready to start simulation', '');
      });
    });
  </script>
</body>
</html>

